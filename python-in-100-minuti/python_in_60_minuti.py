# -*- coding: utf-8 -*-
"""python_in_60_minuti.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/ProfAI/Python-in-100-minuti/blob/master/python_in_100_minuti.ipynb

# Da zero a Python in 100 minuti

## Indice
 * [Introduzione](#intro)
 * [Input e output](#io)
 * [Le variabili](#var)
 * [Tipi di dati](#types)
 * [Liste, tuple e set](#list)
 * [Dizionari](#dict)
 * [I cicli](#loop)
 * [Istruzioni condizionali](#if)
 * [Le funzioni](#func)
 * [Le classi](#oop)
 * [I moduli](#module)

<a id='intro'></a>
## Introduzione
Python è uno dei linguaggi di programmazione più utilizzati al mondo, grazie alla sua semplicità e versalità viene sfruttato per moltissimi scopi diversi come lo sviluppo di applicazioni desktop, web e networking ma da del suo meglio proprio nel calcolo scientifico e nel **machine learning**.
<br><br>
Python è un **linguaggio interpretato**, questo vuol dire che, a differenza di un lingaggio compilato, il codice non viene direttamente compilato in un file eseguibile (ad esempio i file .exe di Windows), ma viene interpretato da un altro software, chiamato proprio *interprete*, che poi lo esegue. Questo vuol dire che lo stesso codice Python può essere eseguito su qualsiasi sistema operativo sulla quale sia disponibile l'interprete, come Windows, Unix/Linux, Macintosh e sistemi mobili come Android e iOS.
<br><br>
In realtà, prima di essere eseguito tramite l'interprete, un programma Python viene pre-compilato in un formato chiamato *bytecode*, il ché lo rende più performante di diversi linguaggi interpretati, anche se non al livello di linguaggi compilati a basso livello come C/C++ (Python è realizzato proprio in linguaggio C).

<a id='io'></a>
## Input e Output
Le funzioni fondamentali di un qualsiasi linguaggio di programmazione sono quelle che ci permettono di prendere delle informazioni in ingresso e mostrarle in uscita.
<br>
Con Python possiamo stampare dei dati su schermo utilizzando la funzione *print*.
"""

print("Ciao mondo")

"""In questo caso il dato che abbiamo stampato è una stringa, cioè del testo, che viene racchiusa tra doppi apici. 
<br>
Per acquisire dei dati possiamo invece utilizzare la funzione input.
"""

name = input("Come ti chiami ? ")
print("Felice di conoscerti",name)

"""In questo caso abbiamo immagazzianto l'input inserito da tastiera all'interno di una **variabile** che poi abbiamo stampato su schermo.

<a id='var'></a>
## Le variabili
Una variabile serve per immagazzinare dati, possiamo assegnare un dato a una variabile usando l'operatore di assegnazione (=).
"""

print(5)

num = 5
print(num)

word = "ciao"
print(word)

"""Il nome della variabile viene definito da noi, è buona norma utilizzare un nome che rappresenta il contenuto della variabile, in modo da facilitare la lettura del codice."""

cat = input("Inserisci un nome per il tuo nuovo gatto: ")
print(cat+" è il tuo nuovo padrone")

"""<a id='types'></a>
## Tipi di dati
Python è un linguaggio **non tipizzato** questo vuol dire che il tipo di dato che una variabile può contenere non va dichiarato espressamente. Per conoscere il tipo di dato che una variabile contiene possiamo usare la funzione type.
"""

var = "ciao"
type(var)

"""I tipi di dati principali che Python ci mette a disposizine sono i seguenti:
 * **Interi**: numeri interi (es: 5, 10,  123)
 * **Float**: numeri in virgola mobile (es: 4.34, 5.31, 0.17)
 * **Stringhe**: del testo (es: "ciao", "abc", "Yo, come butta fratello ?")
 * **Booleani**: possono avere solo due valori vero/falso (True/False)
"""

# Intero
var = 5

# Float
var = 4.15

# Stringa
var = "ciao ciao"

# Boolean
var = True

type(var)

"""**NOTA BENE** Jupyter Notebook e l'interprete interattivo di Python stampano l'output dell'ultima istruzione anche senza utilizzare esplicitamente la funzione *print*.

Con python possiamo convertire un tipo di dato in un altro con un'operazione chiamata casting

#### ES. 1: Casting da intero a stringa
"""

# Creiamo una variabile che contiene un'intero
var = 5

# Convertiamo la variabile da intero a stringa
var = str(var)

print(var)
print(type(var))

"""#### ES. 2: Casting da intero a float"""

# Creiamo una variabile che contiene un intero
var = 1

# Convertiamo la variabile da intero a float
var = float(var)

print(var)
print(type(var))

"""#### ES. 3: Casting da stringa a intero"""

# Creiamo una variabile che contiene una stringa
var = "10"

# Convertiamo la variabile da stringa a intero
var = int(var)

print(var)
print(type(var))

"""### Formattazione
Un'altra soluzione consiste nell'utilizzare l'operatore di formattazione (%)
"""

cat_lives = 7
print("I gatti hanno %d vite" % cat_lives)

"""Il carattere dopo l'operatore di formattazione indica il tipo di variabile, i principali sono:
* **%d**: numero intero
* **%f**: numero in virgola mobile
* **%s**: stringa

Per la lista completa, dai uno sguardo [qui](https://docs.python.org/3/library/stdtypes.html#old-string-formatting).
<br>
Possiamo anche utilizzare più operatori di formattazione all'interno di una stringa.
"""

cat_lives = 7

cat = input("Come si chiama il tuo gatto ? ")
my_cat_lives = input("Quante vite ha perso ? ")

my_cat_lives = int(my_cat_lives)

my_cat_lives = cat_lives-my_cat_lives

print("Il tuo gatto %s ha ancora %d vite" % (cat, my_cat_lives))

"""**NOTA BENE** la funzione input ritorna una stringa, quindi abbiamo dovuto usare il casting per convertirla in un'intero.

Un'altra soluzione ancora, quella consigliata per Python 3, consiste nell'utilizzare il metodo lo *format*
"""

cat_lives = 7

cat = input("Come si chiama il tuo gatto ? ")
my_cat_lives = int(input("Quante vite ha perso ? "))
my_cat_lives = cat_lives-my_cat_lives

print("Il tuo gatto {name} ha ancora {lives} vite".format(name=cat, lives=my_cat_lives))

"""Se usiamo una versione di Python superiore alla 3.6 abbiamo anche un'altro modo per formattare le stringhe, chiamato **f-strings**"""

cat_lives = 7

cat = input("Come si chiama il tuo gatto ? ")
my_cat_lives = int(input("Quante vite ha perso ? "))
my_cat_lives = cat_lives-my_cat_lives

# inseriamo una f prima della stringa per indicare la formattazione
print(f"Il tuo gatto {cat} ha ancora {my_cat_lives} vite")

"""## Operazioni aritmetiche

Con Python possiamo eseguire le varie **operazioni matematiche** utilizzando l'operatore corretto
"""

# somma
print(5+3)

# sottrazione
print(4-1)

# prodotto
print(3*2)

# divisione
print(4/2)

# resto
print(5%2)

# unire due stringhe
print("5"+"2")

"""Come vedi dall'ultimo print, l'utilizzo dell'operatore somma (+) su due stringhe ha l'effetto di unirle.
<br>
Il testo inserito dopo il carattere # è un **commento**, il suo scopo è quello di permetterci di inserire annotazioni nel codice, che poi verranno scartate dall'interprete e quindi non utilizzate in alcun modo dal programma.
<br><br>
E' possibile anche stampare più dati, anche di tipo differente, semplicemente separandoli con una virgola, se si tratta solo di stringhe possiamo anche utilizzare l'operatore somma (+).
"""

print("5 + 3 = "+"8")
print("5 + 3 =",8)
print("5 + 3 =",5+3)

cat = input("Inserisci un nome per il tuo nuovo gatto: ")
print(cat+" è il tuo nuovo padrone")

cat_lives = 7
print("I gatti hanno "+str(cat_lives)+" vite")

"""## Le Eccezioni
Cosa succede se proviamo a sommare una parola e un numero ?
"""

cat_lives = 7
print("I gatti hanno "+cat_lives+" vite")

"""Come vedi il tentativo di sommare una parola e un numero ha causato un'errore, che in Python vengono chiamate **eccezioni**.<br> 
Ogni volta che si verifica un'eccezione Python ci mostra:
 * la riga esatta in cui si è verificato (La freccia verde)
 * il tipo di eccezone (TypeError)
 * una breve descrizione (*can only concatenate str (not "int") to str*)
 
Un altro esempio di eccezione è quella che avviene se proviamo a convertire una parola in numero.
"""

# Creiamo una variabile che contiene un intero
var = "boh"

# Convertiamo la variabile da intero a float
var = float(var)

print(var)
print(type(var))

"""**APPROFONDIMENTO**
 Possiamo gestire le eccezioni con dei try-except, non tratteremo l'argomento in questo tutorial, ma puoi trovare informazioni in merito [qui](https://docs.python.it/html/tut/node10.html)

<a id='list'></a>
## Liste, Tuple e Set
Ogni linguaggio di programmazione ci da la possibilità di creare sequenze di dati, Python lo fa con tre tipi, le liste e le tuple e i set
<br>
Possiamo creare una lista di dati semplicemente racchiudendoli tra parentesti quadre e separandoli con una virgola
"""

weights = [85.2, 80.3, 76.5 ,72.7, 69.8, 68.0,]
print(weights)
print(type(weights))

"""In questo caso abbiamo creato una lista che contiene i primi 7 valori della successione di Fibonacci. 
<br>
Possiamo conoscere la lunghezza di una lista utilizzando la funzione len.
"""

len(weights)

"""### Indexing

Per accedere ad un elemento della lista dobbiamo inserire il suo **indice** tra parentesi quadre, questa opeazione è chiamata *indexing*.
<br>
**NOTA BENISSIMO** In Python e in quasi tutti i linguaggi di programmazione gli indici partono da 0.
"""

# stampiamo il primo elemento della lista
print(weights[0])

#stampiamo il secondo elemento della lista
print(weights[1])

"""L'utilizzo del - davanti all'indice ci permette di accedere alla lista dall'ultimo elemento verso il primo, in questo caso l'indice parte da 1 e non da zero, quindi con -1 accederemo all'ultimo elemento della lista."""

# stampiamo l'ultimo elemento della lista
print(weights[-1])

# stampiamo il terzultimo elemento della lista
print(weights[-3])

"""### Slicing
Possiamo estrarre solo una parte della lista inserendo gli indici di inizio (incluso) e fine (escluso) separati da (:)
"""

# primi 3 elementi della lista
print(weights[:3])

# quarto e quinto elemento 
print(weights[3:5])

# ultimi due elementi
print(weights[-2:])

# fino ali ultimi 2 elementi
print(weights[:-2])

"""Possiamo anche utilizzare un terzo valore, che indicherà il verso della selezione, valore 1: da sinistra a destra (valore di default) valore -1 da destra a sinistra (per ribaltare la lista)."""

# dall'ultimo al primo
weights[::-1]

"""### Verifica
Possiamo verificare se un elemento è contenuto nella lista con lo statement *in*, questo ritorna True se l'elemento è contenuto nella lista, altrimenti ritorna False (*in* è molto utile utilizzato per creare istruzioni condizionali, di cui parleremo più sotto).
"""

print(72.7 in weights)

people = ["Giuseppe", "Francesco", "Antonio"]
print("Sigismundo" in l)

"""### Modifica

Possiamo modificare il valore di un elemento della lista semplicemente accedendo ad esso e eseguendo un'assegnazione.
"""

weights = [85.2, 80.3, 76.5 ,72.7, 69.8, 68.0]

print("Vecchio peso di partenza: %.1f" % weights[0])

# sostituiamo il valore alla posizione 0 con un 84.2
weights[0]=84.2

#stampiamo il primo elemento della lista
print("Nuovo peso di partenza: %.1f" % weights[0])

"""Per modificare il contenuto di una lista possiamo sfruttare i seguenti metodi:
* **append(e)** aggiunge un elemento e in fondo alla lista
* **insert(i,e)** aggiunge l'elemento e all'indice i della lista
* **remove(e)** rimuove l'elemento e dalla lista
* **pop(i)** rimuove l'elemento all'indice i

"""

# creiamo una lista contenente solo due elementi
animals = ["topo", "gatto"]

# aggiungiamo la parola "cane" alla lista
animals.append("cane")
print(animals)

# rimuoviamo la parola "gatto" dalla lista
animals.remove("gatto")
print(animals)

# aggiungiamo un sinonimo di gatto alla posizione 1
animals.insert(1,"essere superiore")
print(animals)

# rimuoviamo l'elemento alla posizione 1
animals.pop(1)

# aggiungiamo un sinonimo più realistico di gatto alla posizione 1
animals.insert(1,"dominatore della terra, dell'universo e di tutto il creato")
print(animals)

"""Passiamo alle tuple, possiamo creare una tupla inserendo gli elementi tra parentesi tonde e separandoli con una virgola"""

animals_t = ("topo", "gatto", "cane", "uomo")
print(animals_t)
print(type(animals_t))

"""Per l'accesso agli elementi vale la stessa regola delle liste, quindi indexing e slicing."""

# Stampiamo il primo elemento della tupla
print(animals_t[0])

# Stampiamo l'ultimo elemento della tupla
print(animals_t[-1])

"""Che differenza c'è tra una lista e una tupla ? La differenza consiste nel fatto che, una volta creata, una tupla non può essere modificata."""

t[0] = 5

"""Come vedi il tentativo di modificare un'elemento della lista scatena un'eccezione di tipo TypeError, che ci informa proprio del fatto che gli elementi di una tupla non possono essere modificati. Se questa cosa non ci sta bene possiamo sempre convertira la tupla in lista (e viceversa)."""

animals = list(animals_t)
print(animals)
print(type(animals))

"""Le stringe in Python possono essere considerate come tuple di caratteri, questo vuol dire che possiamo usare le operazioni di indexing e slicing anche su di esse."""

s = "Hello world"

print(s[:5])
print(s[::-1])

s[4]="s"

"""Anche in questo caso il tentativo di modificare un elemento ha scatenato la stessa eccezione.

### Altre funzioni utili per liste e tuple
"""

hello_list = ["Ciao","Hello","Hola","Salut","Hallo","Ciao"]
hello_tuple = ("Ciao","Hello","Hola","Salut","Hallo","Ciao")

# ottieni l'indice dell'elemento
print(hello_list.index('Salut'))
print(hello_tuple.index('Salut'))

# conta quante volte è presente un'elemento
print(hello_list.count('Ciao'))
print(hello_tuple.count('Ciao'))

"""Veniamo ai set, i set sono insiemi di elementi unici non ordinati, questo vuol dire che un set non può contenere due volte lo stesso elemento e che non tiene conto della disposizione degli elementi al suo interno.
<br>
Possiamo creare un set inserendo gli elementi tra parentesi graffe e separandoli con una virgola.
"""

my_set = {1,2,2,3,4,5,5}
print(my_set)
print(type(my_set))

"""Come vedi gli elementi duplicati sono stati rimossi. Vediamo alcune funzioni utili per lavorare con i set."""

# creiamo un set di nomi di persona
names = {"Giuseppe","Federico","Antonio","Matteo"}
print(names)

# aggiungiamo un elemento al set
names.add("Lorenzo")
print(names)

# se il nome è già presente, non verrà aggiunto
names.add("Federico")
print(names)

# rimuoviamo un nome
names.remove("Antonio")
print(names)

# se il nome non è presente otterremo un'eccezione KeyError
# in tal caso possiamo piuttosto usare discard
names.discard("Paolo")
print(names)

# estraiamo un elemento dal set
name = names.pop()
print(name)
print(names)

# svuoitamo il set
names.clear()
print(names)

"""Possiamo convertire una lista in un set e vice versa utilizzando il casting.
<br>
**NOTA BENE** convertendo una lista in un set, gli elementi al suo interno verrano mischiati e i duplicati verranno rimossi.
"""

my_list = ["Giuseppe","Federico","Giuseppe","Antonio","Matteo","Matteo"]
print(my_list)
print(type(my_list))

my_set = set(my_list)
print(my_set)
print(type(my_set))

my_list = list(my_set)
print(my_list)
print(type(my_list))

"""Possiamo anche creare un set immutabile utilizzando **frozenset**, in questo caso una volta creato non potremo più aggiungere o rimuovere elementi dal set."""

names = frozenset({"Giuseppe","Federico","Antonio","Matteo"})
print(names)

"""<a id='dict'></a>
## Dizionari
Un dizionario è un tipo Python che ci permette di salvare dei dati in un formato chiave valore, in maniera tale da poter utilizzare la chiave per accedere al valore. Possiamo creare un dizionario con Python racchiudendolo tra parentesi graffe e separando chiavi e valori con (:)
"""

# Creiamo un dizionario con una lista della spesa
# specificando cosa comprare come chiave e la quantità come valore
items = {"latte":3,"riso": 2, "tofu":5}
type(items)

"""Possiamo accedere ad un elemento del dizionario inserendo la chiave tra parentesi quadre"""

items["tofu"]

"""Se la chiave è inesistente otterremo un'eccezione di tipo KeyError."""

items["cereali"]

"""Possiamo aggiungere un'altro elemento al dizionario semplicemente inserendo la chiave tra parentesi quadre ed eseguendo un'assegnazione"""

items["cereali"]=1
print(items)

"""E' possibile inserire all'interno di un elemento del dizionario un'altro dizionario."""

items["yogurt"] = {"fragola":2, "bianco":3}
print(items)

"""<a id='loop'></a>
## I cicli
I cicli ci permettono di eseguire una serie di istruzioni in maniera ciclica.
<br>
Un'esempio classico di ciclo è il **ciclo for**, utilizzato da molti linguaggi di programmazione, Python incluso.
<br>
Utilizziamolo per stampare una serie di numeri
"""

n = input("Fino a che numero vuoi stampare ? ")
n = int(n)

for i in range(0,n):
    print(i)

"""La funzione range ritorna una sequenza di numeri, in questo caso che va da 0 a n, dove n è la variabile definita da noi con la fuzione input e ad ogni iterazione del ciclo la variabile i verrà incrementata di uno e otterrà il valore dell'i-esimo numero della sequenza, fino al valore n.
<br>
Passando un'unico valore come input della funzione range, questa farà partire la sequenza dal valore di default zero.
<br><br>
**NOTA BENISSIMO** Abbiamo lasciato 4 spazi prima dell'istruzione all'interno del ciclo for, questi spazi sono conosciuti l'**indentazione** e permettono all'interprete Python di comprendere il contesto delle istruzioni (ad esempio nel nostro codice permettono di comprendere quali istruzioni devono essere eseguite all'interno del ciclo for). Diversi linguaggi di programmazione, come C/C++, Java e Javascript, utilizzano le parentesi graffe per identifcare il contesto delle istruzioni, Python piuttosto forza ad usare l'indentazione per migliorare la leggibilità del codice (e lo fa benissimo !). I 4 caratteri per l'indentazione sono uno standard proposto nel [PEP 8](https://www.python.org/dev/peps/pep-0008/), in realtà è anche possibile utilizzare un numero differente di spazi (purché sia consistente in tutto il codice) oppure lo shift. Un blocco di codice indentanto viene sempre introdotto da (:) alla fine della riga precedente.
<br>
Se non indentiamo l'istruzione sotto il ciclo for otterremo un'eccezione di tipo *IndentationError*.
"""

for i in range(0,10):
print(i)

"""Implementiamo un ciclo for per il calcolo della successione di Fibonacci fino ad un indice definito da noi. Se non conosci la successione di Fibonacci, ogni elemento della sequenza è la somma dei due valori precedenti, per approfondire dai uno sguardo a [Wikipedia](https://it.wikipedia.org/wiki/Successione_di_Fibonacci)"""

#n = input("Quanti numeri di Fibonacci vuoi stampare? ")
#n = int(n)

#Possiamo sintetizzare le due istruzioni sopra in un unico comando
n = int(input("Quanti numeri di Fibonacci vuoi stampare? "))

fib_num = 0
next_fib_num = 1

for i in range(n):
    #Salviamo il valore successivo in una variabile temporanea
    tmp = next_fib_num
    #Otteniamo il nuovo valore successivo sommando quello corrente
    next_fib_num+=fib_num
    #Assegnamo il valore successivo della successione a quello corrente
    fib_num = tmp
  
    print("%d° numero di Fibonacci = %d" % (i+1, fib_num))

"""Come vedi ci siamo ritrovati a dover immagazzinare il valore del numero successivo in una variabile temporanea, questa è necessaria ogni volta che c'è da invertire il valore di due variabili (questa procedura è chiamata **swapping**)"""

a = "cane"
b = "gatto"

print("a=%s b=%s" % (a,b))

tmp = a
a = b
b = tmp

print("a=%s b=%s" % (a,b))

"""Python ci mette a disposizione una tecnica per eseguire lo **swapping** senza dover utilizzare una terza variabile, ma semplicemente eseguendo l'assegnazione in simultanea separando i valori con una virgola."""

a = "cane"
b = "gatto"

print("a=%s b=%s" % (a,b))

a,b = b,a

print("a=%s b=%s" % (a,b))

"""Alla luce di ciò, modifichiamo il nostro algoritmo per il calcolo della successione di Fibonacci."""

n = int(input("Quanti numeri di Fibonacci vuoi stampare? "))

fib_num = 0
next_fib_num = 1

for i in range(n):
    fib_num, next_fib_num = next_fib_num, next_fib_num+fib_num
    print("%d° numero di Fibonacci = %d" % (i+1, fib_num))

"""Decisamente meglio ! Possiamo utilizzare un ciclo for per iterare sugli elementi di una lista, potresti pensare che il modo per farlo possa essere questo:"""

shopping_list = ["tofu", "latte di soia", "riso basmati","yogurt greco"]

print("La mia lista della spesa:")

for i in range(len(shopping_list)):
    print("%d) %s" % (i+1,shopping_list[i]))

"""e funziona, ma in realtà esiste un metodo migliore per stampare la nostra lista della spesa, possiamo iterare direttamente sugli elementi della lista."""

shopping_list = ["tofu", "latte di soia", "riso basmati","yogurt greco"]

print("La mia lista della spesa:")

for entry in shopping_list:
    print("-"+entry)

"""**NOTA BENE** entry è sempre una variabile il cui nome viene definito da noi, che conterrà ad ogni iterazione il successivo elemento della lista.
<br><br>
Come vedi adesso abbiamo stampato gli elementi della nostra lista della spesa in maniera decisamente più intuitiva, ma non abbiamo più l'indice i. Qualora ci servisse sia l'elemento che l'indice, possiamo utilizzare la funzione *enumerate*, che ci permette di iterare su entrambi.
"""

shopping_list = ["tofu", "latte di soia", "riso basmati","yogurt greco"]

print("La mia lista della spesa:")

for i,entry in enumerate(shopping_list):
    print("%d) %s" % (i+1, entry))

"""Un'altra tiplogia di ciclo utilizzata da Python e da molti altri linguaggi di programmazione è il **ciclo while**, per creare un ciclo while dobbiamo definire un'**espressione booleana**, che ci permettono di eseguire confronti tra i dati, le espressioni booleane disponibili in python sono:

* **==**: ritorna True se le due espressioni sono uguali, altrimenti ritorna False
* **!=**: ritorna True se le due espressioni sono diverse, altrimenti ritorna False
* **>**: ritorna True se la prima espressione è maggiore della seconda (solo numeri)
* **>=**: ritorna True se la prima espressione è maggiore o uguale alla seconda (solo numeri)
* **<**: ritorna True se la prima espressione è minore della seconda (solo numeri)
* **<=**: ritorna True se la prima espressione è minore o uguale alla seconda (solo numeri)
"""

print(1==1)
print(3+2==6-1)
print(1!=1)

print("\n")

print(5>6)
print(5<5)
print(5<=5)

print("\n")

print("gatto"=="gatto")
print("gatto"=="cane")
print("cane"!="gatto")

"""Adesso creiamo un ciclo while che verrò eseguito fino a quando la variabile i è minore del numero che abbiamo inserito."""

n = int(input("Fino a che numero vuoi stampare ? "))

i = 0

while i<n:
    print(i)
    i+=1

"""Come vedi la differenza consiste nel fatto che questa volta tocca a noi definire l'indice e incrementarlo di volta in volta, il vantaggio di questo approccio è che possiamo modificare l'indice a nostro piacimento e non solamente incrementandolo di un valore."""

n = int(input("Fino a che numero dispari vuoi stampare ? "))

i = 1

while i<n:
    print(i)
    i+=2

"""Nel codice c'è un problema, se inseriamo una lettera o una parola, piuttosto che un numero, verrà generata un'eccezione di tipo ValueError, dato che non è possibile stabilire se l'indice è minore di una stringa. Cosa fare in questi casi ? Dobbiamo controllare preventivametne se l'input inserito è effettivamente un numero, possiamo farlo con un'istruzione condizionale.

<a id='if'></a>
## Istruzioni condizionali
Le istruzioni condizionali ci permettono di eseguire del codice solo se una determinata condizione è soddisfatta, la condizione va definita sempre tramite le espressioni booleane. Conoscendo l'espressioni booleane, possiamo definire un'istruzione condizionale inserendo un'espressione dentro un **if**, il codice indentato sotto l'if verrà eseguito solo se la condizione sopra è soddisfatta, cioè se il suo risultato è *True*.

Conoscendo l'espressioni booleane, possiamo definire un'istruzione condizionale inserendo un'espressione dentro un **if**, il codice indentato sotto l'if verrà eseguito solo se la condizione sopra è soddisfatta, cioè se il suo risultato è *True*.
"""

n = input("Inserisci un numero: ")
n = int(n)

if n%2==0:
    print("%d è un numero pari" % n)

"""Se il resto della divisione del numero per due è zero, allora si tratta di un numero pari e lo stampiamo. Se invece è un numero dispari ? Per gestire il caso in cui la condizione definita nell'if non è soddisfatta possiamo usare un **else**"""

n = input("Inserisci un numero: ")
n = int(n)

if n%2==0:
    print("%d è un numero pari" % n)
else:
    print("%d è un numero dispari" % n)

"""Possiamo anche gestire più casi utilizzando degli **elif**."""

n = int(input("Da quanti anni programmi ? "))

if n<0:
    print("Hai inventato il viaggio nel tempo ?")
elif (n>=0 and n<=1):
    print("Sei un novellino !")
elif (n>1 and n<=3):
    print("Stai imparando !")
elif (n>3 and n<=5):
    print("Sarai già bravo !")
elif (n>5 and n<=10):
    print("Sarai molto bravo !")
else:
    print("Sarai un fenomeno !")

"""All'interno degli *elif* abbiamo inserito due condizioni unendole con un *and*, questo è un'**operatore logico**.

### Operatori logici
in Python abbiamo i seguenti operatori logici:
 * **and**: ritorna True se entrambe le due condizioni sono True, altrimenti ritorna False
 * **or**: ritorna True se almeno una delle due condizioni è True, altrimenti ritorna False
 * **not**: esegue una negazione, se la condizione è True ritornerà False, se è False ritornerà True
"""

# entrambe le condizioni sono soddisfatte
print(1==1 and "casa"!="albergo")

# la prima condizione non è soddisfatta
print(1==2 and "casa"!="albergo")

# la prima condizione non è soddisfatta
print(1==2 or "casa"!="albergo")

# Nessuna condizione è soddisfatta
print(1==2 or "casa"=="albergo")

# Nessuna condizione è soddisfatta
print(not(1==2 or "casa"=="albergo"))

# Tutte le condizioni sono soddisfatte
print(not(1==1 or "casa"!="albergo"))

"""Riprendendo l'esempio della successione di Fibonacci, possiamo verificare che l'input sia effettivamente un numero in questo modo"""

n = input("Quanti numeri di Fibonacci vuoi stampare? ")

if not n.isdigit():
    print("Numero non valido !")
else:
    n = int(n)
    fib_num = 0
    next_fib_num = 1

    for i in range(n):
        fib_num, next_fib_num = next_fib_num, next_fib_num+fib_num
        print("%d° numero di Fibonacci = %d" % (i+1, fib_num))

"""**NOTA BENE**
* *isdigit* è un metodo della classe string (ne parleremo sotto), questo ritorna True se la stringa contiene un numero, altrimenti ritorna False
* nota la doppia indentazione nel ciclo for, necessaria per indicare che le istruzini fanno parte del ciclo for, che a sua volta fa parte del blocco else.

<a id='func'></a>
## Le funzioni
Le funzioni ci permettono di riutilizzare blocchi di codice prendendo eventualmente dei dati in ingresso, chiamati **argomenti** o **parametri** e ritornando un'output. 
<br>
Ad esempio, scriviamo una funzione per il calcolo dell'aria di un triangolo.
"""

def compute_area(b,h):
    area = b*h/2
    return area

b = 5
h = 3
area = compute_area(b, h)

print("L'area del triangolo con base %.2f e altezza %.2f è %.2f" %(b,h,area))

"""La funzione viene definita con un *def* seguito dal nome della funzione e tra parentesi il nome dei suoi parametri, il valore che la funzione ritornerà sarà quello inserito dopo *return*.
<br>
Avremmo potuto scrivere la funzione in maniera più compatta inserendo il calcolo direttamente all'interno del return.

"""

def compute_area(b,h):
    return b*h/2

"""Una funzione non deve per forza ritornare un valore, ad esempio può essere utilizzata per stampare un'ouput."""

def print_shopping_list(shopping_list):
    
    print("La tua lista della spesa:")
    
    for i, entry in enumerate(shopping_list):
        print("%d) %s" % (i+1, entry))
    
   
shopping_list = ["tofu", "latte di soia", "riso basmati","yogurt greco"]
print_shopping_list(shopping_list)

"""I Parametri di una funzione possono contenere dei valori di default che verranno utilizzati nel caso in cui non specifichiamo tali parametri quando chiamiamo la funzione."""

def print_shopping_list(shopping_list, owner="Giuseppe"):
  
  print("La lista della spesa di %s:" % owner)
  
  for i, entry in enumerate(shopping_list):
    print("%d) %s" % (i+1, entry))
    
   
shopping_list = ["tofu", "latte di soia", "riso basmati","yogurt greco"]
print_shopping_list(shopping_list)

# Stampiamo una linea vuota per separare le due liste
print("\n")

shopping_list = ["croccantini ", "latte", "scatolette di tonno","plutonio"]
print_shopping_list(shopping_list, owner="Elon") # Elon è il nome del mio gatto :)

"""**NOTA BENE** I parametri senza valore di default vanno sempre inseriti **prima** dei parametri con valore di defualt, altrimenti python genererà un'eccezione del tipo *SintaxError*, se vuoi sperimentarlo inserisci il parametro *owner* prima del parametro *shopping_list* nella definizione della funzione qui sotto.

<a id='oop'></a>
## Basi di programmazione ad oggetti
Python supporta molti **paradigmi di programamazione**, che caratterizzano lo stile del codice. Il paradigma basato sulle funzioni è conosciuto come **Programmazione Procedurale (Procedural Programming)** (le funzioni vengono anche chiamate procedure). Un'altro paradigma di programmazione molto utilizzato è la **Programmazione Orientata agli Oggetti (Object Oriented Programming - OOP)**. 
<br>
L'elemento centrale della programmazione ad oggetti sono (sorpresa sorpresa) **gli oggetti**, che ci permettono di racchiudere funzioni e variabili all'interno di un'unica entità e rendono il codice maggiormente riutilizzabile e più semplice da mantenere.
<br><br>
Per creare un oggetto dobbiamo definire una classe che lo rappresenterà, le funzioni definite all'interno della classe sono chiamati **metodi** della classe.
<br>
Ad esempio, creiamo una classe che rappresentà un triangolo, i cui metodi ci permettono di calcolarne area e perimetro.
"""

class Triangle:
  
    def area(self, b, h):
        return b*h/2.
  
    def perimeter(self, a, b, c):
        return a+b+c
  
# istanziamo la classe (creiamo l'oggetto)
triangle = Triangle()

print("Area del triangolo: %2.f" % triangle.area(3.,4.))
print("Perimetro del triangolo: %2.f" % triangle.perimeter(5.,3.,5.))

"""Come puoi vedere ogni metodo della classe ha come primo parametro *self*, questo ci permette di identificare attributi e metodi all'interno della classe stessa.
Alla riga 10 creiamo l'oggetto, che a livello concettuale è un'**istanza** della classe triangolo. Per calcolare area e perimetro dobbiamo passare di volta in volta le informazioni sulle misure di base, altezze e lati del triangolo, che funziona ma è concettualmente sbagliato, un'oggetto deve contenere le proprie informazioni al suo interno, in apposite variabili chiamate **attributi**.
<br>
Possiamo definire gli attributi della classe all'interno di un **metodo costruttore** che in Python è l'*init*
"""

class Triangle:
  
  
    def __init__(self, a, b, c, h):
    
        # Questa istruzione è equivalente a quella sotto
        #self.a, self.b, self.c, self.h = a, b, c ,h

        self.a = a
        self.b = b
        self.c = c
        self.h = h

    
    def area(self):
            return self.b*self.h/2
    
    
    def perimeter(self):
        return self.a+self.b+self.c
  
triangle = Triangle(5.,3.,5.,4.)
print("Area del triangolo: %2.f" % triangle.area())
print("Perimetro del triangolo: %2.f" % triangle.perimeter())

"""Ogni metodo può accedere agli attributi della classe utilizzando *self*, lo stesso discorso vale per l'utilizzo di metodi all'interno di altri metodi."""

class Triangle:
  
  
    def __init__(self, a, b, c, h):
        self.a, self.b, self.c, self.h = a, b, c ,h

    
    def area(self):
        return float(self.b)*float(self.h)/2.
  
  
    def perimeter(self):
        return self.a+self.b+self.c
  
  
    def print_info(self):
        print("Area del triangolo: %2.f" % self.area())
        print("Perimetro del triangolo: %2.f" % self.perimeter())


triangle = Triangle(5.,3.,5.,4.)
triangle.print_info()

"""Le classi possono essere organizzate in moduli, cioè file python esterni a quello sulla quale stiamo lavorando (parlemeno di questo argomento sotto), in ogni caso possiamo vedere metodi e attributi di una classe usando la funzione help."""

class Triangle:
  

    def __init__(self, a, b, c, h):
        self.a, self.b, self.c, self.h = a, b, c ,h

    
    def area(self):
        return float(self.b)*float(self.h)/2.
  
  
    def perimeter(self):
        return self.a+self.b+self.c
  
  
    def print_info(self):
        print("Area del triangolo: %2.f" % self.area())
        print("Perimetro del triangolo: %2.f" % self.perimeter())


triangle = Triangle(5.,3.,5.,4.)
help(triangle)

"""Una classe può contenere molti metodi differenti, possiamo utilizzare le **Docstrings** per documentare a cosa serve una classe e cosa fanno ognuno dei suoi metodi"""

class Triangle:
  
  
    """
    Questa classe rappresenta un triangolo
    """
    
    def __init__(self, a, b, c, h):
        self.a, self.b, self.c, self.h = a, b, c ,h

    
    def area(self):
        
        """
        Calcolo dell'area del triangolo
        """
        
        return float(self.b)*float(self.h)/2.
  
  
    def perimeter(self):
        
        """
        Calcolo del perimetro del triangolo
        """
        
        return self.a+self.b+self.c
  
  
    def print_info(self):
        
        """
        Stampiamo area e perimetro del triangolo
        """
        
        print("Area del triangolo: %2.f" % self.area())
        print("Perimetro del triangolo: %2.f" % self.perimeter())


triangle = Triangle(5.,3.,5.,4.)
help(triangle)

"""Questa piccola guida aveva lo scopo di introdurti agli oggetti, ma la programmazione orientata agli oggetti è un'argomento molto più vasto, se vuoi approfondirlo ti consiglio di dare uno sguardo al [Corso di Programmazione in Python di NinjaCloud](https://www.udemy.com/python-corso-pratico-di-programmazione/?couponCode=PROFAI)

<a id='module'></a>
## I moduli
I moduli ci permettono di organizzare il codice dei nostri programmi in più file, separandone le parti e garantendo una riutilizzabilità ottimale del codice. 
<br>
Nella pratica, un modulo non è altro che uno script python (.py), con dentro definite delle classi o delle funzioni, possiamo utilizzare tali classi o tali funzioni all'interno di un'altro script python utilizzando *import*
<br><br>
**NOTA BENE** i due script devono trovarsi all'interno della stessa directory
"""

import script

print(type(script))

script.hello_world()

"""Come vedi possiamo eseguire una funzione contenuta in un modulo possiamo usare una sintassi del tipo *nome_modulo.nome_funzione()*
<br>
Il discorso è uguale per le classi
"""

import geometry

triangle = geometry.Triangle(3., 5., 4., 6.)
print("L'area del triangolo è %.2f" % triangle.area())

square = geometry.Square(5.)
print("L'area del quadrato è %.2f" % square.area())

rectangle = geometry.Rectangle(5.,4.)
print("L'area del rettangolo è %.2f" % rectangle.area())

"""Possiamo anche decidere di importare solo le funzioni o classi che ci servono utilizziando una sintessi del tipo *from modulo import function* se vogliamo importare più classi o funzioni basta separarle da una virgola."""

from geometry import Triangle

triangle = Triangle(3., 5., 4., 6.)
print("L'area del triangolo è %.2f" % triangle.area())

from geometry import Square, Rectangle

square = Square(5.)
print("L'area del quadrato è %.2f" % square.area())

rectangle = Rectangle(5.,4.)
print("L'area del rettangolo è %.2f" % rectangle.area())

"""### La Standard Library

La [Standard Library](https://docs.python.org/3/library/) di Python mette a disposizione tutta una serie di moduli già realizzati per molti utilizzi differenti.
<br>
Ad esempio il [modulo os](https://docs.python.org/3/library/os.html) ci permette di utilizzare molte funzioni del nostro sistema operativo.
"""

import os

# otteniamo il path alla directory corrente
cwd = os.getcwd()
print(cwd)

"""Oppure il [modulo datetime](https://docs.python.org/3/library/datetime.html) ci permette di ottenere data e ora corrente ed effetturare operazioni su date."""

import datetime

#il metodo now ci permette di ottenere data e ora correnti
print(datetime.datetime.now())

"""Un'altro modulo simile è il [modulo time](https://docs.python.org/3/library/time.html), vediamo un esempio di come utilizzarlo per calcolare il tempo di esecuzione di una funzione."""

import time

n = 2
pow = 10

n_pow = n

tick = time.time()
for _ in range(pow):
  n_pow*=n

duration = time.time()-tick
  
print("La %d° potenza di %d è %d" % (pow, n, n_pow))
print("Tempo di esecuzione: %.5f secondi" % duration)

"""il metodo time() ci permette di ottenere il timestamp corrente, cioè i secondi trascorsi dall'epoca. L'epoca è il punto in cui il tempo inizia per un computer e dipende dal sistema operativo, ad esempio per Unix/Linux è l'1 Gennaio 1970 per Windows è L'1 Gennaio 1601."""

from time import time
from math import pow

n = 2
pow = 10

tick = time()

pow(2,10)

# il tempo di esecuzione è la differenza tra i timestamp

duration = time()-tick

print("La %d° potenza di %d è %d" % (pow, n, n_pow))
print("Tempo di esecuzione: %.5f secondi" % duration)

"""Come vedi abbiamo ottenuto un errore, riesci a vederlo ? Il problema è che la funzione pow del modulo math si chiama come la nostra variabile e Python pensa che stiamo cercando di trattare la nostra varaibile come una funzione, quindi genera un'eccezione di tipo TypeError. La soluzione migliore sarebbe rinominare la variabile, noi piuttosto creiamo un aias della funzione pow."""

from time import time
from math import pow as power

n = 2
pow = 10

tick = time()

n_pow = power(n, pow)

duration = time()-tick

print("La %d° potenza di %d è %d" % (pow, n, n_pow))
print("Tempo di esecuzione: %.5f secondi" % duration)

"""### Python Package Index  (PyPI)
Oltre ai moduli della Standard Library, Python ci da la possibilità di installare e utilizzare moduli creati da sviluppatori terzi, contenuti all'interno del Python Package Index (PyPI). Per installare uno di questi moduli possiamo usare pip, il gestore di pacchetti Python per eccellenza, utilizzabile da riga di comando e che viene installato automaticamente insieme a Python (se per qualche oscuro motivo pip non è stato installato insieme a Python, fai riferimento a [questa guida](https://pip.pypa.io/en/stable/installing/) per installarlo manualmente).
<br>
Utilizziamo pip per installare *numpy*, una utilissima libreria Python per il calcolo scientifico.
"""

!pip install numpy

"""**NOTA BENE** pip è un software che va utilizzato da terminale, in Jupyter Notebook possiamo eseguire un comando da terminale aggiungendo un (!) prima del comando.
<br>
Una volta installato possiamo usare Numpy importandolo come qualsiasi altro modulo.
"""

from time import time
import numpy as np

n = 2
power = 10

tick = time()

np_pow = np.power(n, power)

duration = time()-tick

print("La %d° potenza di %d è %s" % (power, n, n_pow))
print("Tempo di esecuzione: %.5f secondi" % duration)

"""Altri comandi utili di pip sono:
* pip uninstall *nome_modulo*  (per rimuovere un modulo)
* pip install *nome_modulo* --upgrade (per aggiornare un modulo)
"""